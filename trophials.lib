//////////////////////////////////////////////////////////////////
version="version trophials.lib 1.0 Jan_2018"; 
category="Tropical geometry";
//////////////////////////////////////////////////////////////////
info="
LIBRARY: trophials.lib Tropicalization of a hypersurface in a linear space
AUTHOR: Christian Juergens
WARNING:
The procedure trophials only works with polymake!
OVERVIEW: 
This library allows to compute the tropicalization of a hypersurface contained in a linear space in the constant coefficient case. Given an homogeneous ideal I=<l_1,...,l_k,f> generated by linear forms l_i and a polynomial of degree d, the procedure trophials computes the bases of the matroid associated to the linear part of the ideal and then computes the relative Newton polytope of f. All data is saved in files for polymake. Then trophials starts an instance of polymake, loads the data and executes trophials_pm, the polymake script that does all the polyhedral computations. The result is saved in a file and loaded from trophials in Singular.
KEYWORDS: tropicalization; 
//////////////////////////////////////////////////////////////////
PROCEDURES:
  trophials()d;	computes tropicalization of a hypersurface in a linear space
";
//////////////////////////////////////////////////////////////////
LIB "all.lib";
LIB "primdec.lib";
//////////////////////////////////////////////////////////////////
proc trophials_tropicalize(ideal I){		/* INPUT: ideal I generated by linear forms and a polynomial */
  int i = 1;
  int n = nvars(basering);	// #variables
  int d = deg(I);		// degree
  list return_list;
  // Check input ideal
  if( size(I) <= 1){
    ERROR("Either the ideal is empty or you consider a hypersurface.");
  }
  if( d == 1 ){
    ERROR("The ideal is linear!");
  }
  if( homog(I) != 1 ){
    ERROR("The ideal is not homogeneous!");
  }
  // Decompose ideal into linear forms and polynomials
  list ideal_decomp = trophials_ideal_decomp(I);
  ideal I_lin=ideal_decomp[1];
  poly polyf = ideal_decomp[2];
  // Check f
  if( size(polyf) <= 1 ){
    ERROR("Polynomial is a monomial!");
  }
  // Check f for divisibility
  int is_div = trophials_div(polyf);
  if( is_div ){
    while( is_div && deg(polyf) >= 2 ){
      polyf = division(polyf,var(is_div))[1][1,1];
      print("Continue with"),polyf;
      is_div = trophials_div(polyf);
      if( is_div != 0 ){
	print("Not divisible anymore, continue ...");
      }
    }
//     print("Continue with the polynomial"),polyf,print("and check ...");
    ideal I = I_lin+polyf;
    print("Check ideal ...");
    print(I);
    if( deg(I) == 1 ){
      ERROR("Ideal is linear now!");
    }
    return_list[1] = I;
  }else{
    print("f not divisible by monomial.");
    return_list[1] = I;
  }
  // Create coefficient matrix
  matrix A = trophials_coefmat(I_lin);
  // Dimension check: we only deal with curves in tropical planes!
  if( n - rank(A) != 3){
    ERROR("The linear space is not 2-dimensional!");
  }
  // Check whether redundant linear forms exist
  if( rank(A) != size(I_lin) ){
    ERROR("There are redundant linear forms!");
  }
  // Compute all bases of the coefficient matrix
  list bases = trophials_basis(A);
  if( size(bases) ==  binomial(ncols(A),rank(A)) ){
    print("The ambient space is L_n,k=B(U_n,k).");
  }
  // Compute bases of the matroid ...
  list c_bases;
  for(i = 1; i <= size(bases); i++){
    c_bases[i] = trophials_complement(bases[i],n);
  }
  // Compute relative supports
  list S = trophials_relative_support(I,bases);
  // Save the data in "polymake_data_XY" with basis number XY
  string write_name =":w polymake_data_";			// These are the names of the files. Do not change!
  string read_name ="singular_data";
  for(i = 1; i <= size(S); i++){
    res = "use application \"tropical\"; use vars '$m';"+SMatrixToPMatrix("m",submat(trophials_list_to_matrix(S[i]),intvec(1..size(S[i])),c_bases[i]));
    write(write_name+string(i),res);
  }
  res = "use application \"matroid\"; use vars '$Bases','$n_elements'; "+SListToPArray("Bases",c_bases)+"$n_elements = "+string(n);
  write(write_name+"matroid",res);
  // Start polymake computations
  print("Starting Polymake computations ...");
  int sys = system("sh","polymake --script trophials_pmscript 1");	// polymake calculates all normal resfans  and saves data in "singular_data_XY"
  print("Back to Singular ...");
  // Read the result of the polymake script
  execute(read(read_name));
  // Show the result
  print("----------");
  print("Trop(V(I))");
  print("----------");
  print("Rays:");
  print(rays);
  return_list[2]=rays;
  print("Lineality:");
  print(lineality);
  return_list[3]=lineality;
  print("Weights:");
  print(weights);
  return_list[4]=weights;
  // return result
  return(return_list);
}						/* RETURN: list, 1. used ideal (may be differnt to input ideal), 1. rays, 3. lineality 4. weights */
//////////////////////////////////////////////////////////// USED PROCEDURES //////////////////////////////////////////////////
proc trophials_ideal_decomp(ideal I){		/* INPUT: ideal generated by linear forms and polynomial */
  int n_polys = 0;
  int n_linears = 0;
  list result;
  // Create linear part and extract the polynomial
  ideal I_lin = 0;	// linear part of I 
  poly f = 0;		// polynomial f
  for(int i = 1; i <= size(I); i++){
    if( deg(I[i]) == 1 ){
      I_lin = I_lin + I[i];
      n_linears++;
    }else{
      f = I[i];
      n_polys++;
    }
  }
  result[1] = I_lin;
  result[2] = f;
  // Check the generators
  if( n_polys > 1 ){
    ERROR("More than one non-linear polynomial!");
  }
  if( n_linears == 0 ){
    ERROR("You consider a hypersurface!");
  }
  return(result);
}						/* RETURN: list: 1. entry = linear part of I, 2. entry the polynomial */
proc trophials_div(poly polyf){			/* INPUT: polynomial f */
  for(int i = 1; i <= nvars(basering); i++){
    if( division(polyf,var(i))[2] == 0 ){
      print("Polynomial divisible by"),var(i);
      return(i);
    }
  }
  return(0);
}						/* RETURN: int i = variable that divides f, i = 0 if f is not divisible by variable */
proc trophials_relative_support(ideal I,list bases){	/* INPUT: ideal I, list of bases c_bases */
  list S;
  ideal E;
  int n = nvars(basering);
//   print("n = "),n;
  int size_full_support = int(binomial(size(bases[1])-1+deg(I),deg(I)));
  for(int i = 1; i <= size(bases); i++){
//     print("... for basis"),trophials_complement(bases[i],n);					// <-- computations for basis i
    E = elim(I,bases[i]);
//     print("E = "),E;
//     print(primdecGTZ(E[1]));
//     E = elim(I,trophials_complement(c_bases[i],n));
//     print("elim done!");
    if( size(E) != 1 ){
	    print("Something is wrong with basis"),bases[i];
	    print("After elimination we obtain"),E;
	    ERROR("Figure this out!");
    }
    S[i] = trophials_support(E[1]);								// Save Newton polytope of f_B
//     if( size(S[i]) == size_full_support ){
//       print("Full support!");								// <--- print relative Newton polytopes!
//     }else{
//       print(submat(trophials_list_to_matrix(S[i]),intvec(1..size(S[i])),trophials_complement(bases[i],n)));	// <--- print relative Newton polytopes!
//     }
  }
  return(S);
}							/* RETURN: relative supports of f wrt. c_bases */
proc trophials_support(poly f_temp){		/* INPUT: polynomial f */
  list f_temp_supp;
  int k = 1;
//   f_temp_supp = empty;							// Compute Newton polytope of f_B
  while( size(f_temp) ){
    f_temp_supp[k] = leadexp(f_temp);							// ... we need to get rid of them.
    k++;
    f_temp = f_temp - lead(f_temp);
  }
  return(f_temp_supp);
}						/* RETURN: support of f */
proc trophials_gfan(ideal I){			/* INPUT: arbitrary ideal */
  int n = nvars(basering);
  int i;
  list vars;
  // Check for I prime ideal
  if( size(primdecGTZ(I)) != 1 ){
    print("ATTENTION: ideal is not prime!");	// Warning for Gfan output.
  }
  poly f = 0;
  if( n > 26 ){
    ERROR("Too much variables (more than 26). Quit!");
  }
  vars = "a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z";
  string gfan_ring = "Q[";
  for( i = 1; i <= n - 1; i++){
    gfan_ring = gfan_ring + vars[i] + ",";
  }
  gfan_ring = gfan_ring + vars[n] + "]";
  string gfan_poly = string("{");

  for(int j = 1; j <= size(I); j++){
    f = I[j];
    while( deg(f) != -1 ){
      gfan_poly = gfan_poly + string(leadcoef(f));
      for( i = 1; i <= size(leadexp(f)); i++){
	if( leadexp(f)[i] > 0 ){
	  gfan_poly = gfan_poly + vars[i] + string(leadexp(f)[i]);
	}
      }
      f = f - lead(f);
      if( deg(f) != -1 ){
	if( leadcoef(f) >= 0 ){
	  gfan_poly = gfan_poly + "+";
	}
      }  
    }
    if( j != size(I) ){
      gfan_poly = gfan_poly + ",";
    }
  }
  gfan_poly = gfan_poly + string("}");
  print("-----------------");
  print("Example for gfan:");
  print("-----------------");
  print(gfan_ring);
  print(gfan_poly);
  print("-----------------");
}						/* RETURN: output for gfan */
static proc trophials_place(intvec v,int t, int k, int n,list L){	/* INPUT: start vector v, deep t, position k, variables n, list L */
  while( k <= n ){
    if( t > 0){
      v[k] = v[k] + 1;
      L = trophials_place(v,t-1,k,n,L);
      v[k] = v[k] - 1;
	  k = k + 1;
    }
    else{
      L[size(L)+1] = v;
      return(L);
    }
  }
  return(L);
}						/* RETURN: list */
proc trophials_monomials(int n, int d){		/* INPUT: n number of variables, degree d */
  int i;
  list L;
  intvec v,z;
  for( i = 1; i <= n; i++){
    v[i]=0;
  }
  z = v; /*** save the zero-vector for further purposes ***/
  if( d == 1 ){
    for( i = 1; i <= n; i++){
      v[i] = 1;
      L[i] = v;
      v = z;
    }
  }else{
    L = trophials_place(v,d,1,n,L);
  }
  return(L);
}						/* RETURN: list of monomials in n variables of degree d */
proc trophials_coefmat(ideal I){		/* INPUT: ideal I whose generators have common degree d */
  if( homog(I) != 1 ){
    ERROR("trophials_coefmat: ideal not homogeneous!");
  }
  int n = nvars(basering);
  int l = size(I);
//   int d = 0;
  int d = deg(I[1]);
  int j,k;
  list L = trophials_monomials(n,d);
  if( l >= 2 ){
//     d = deg(I[1]);
    for( int i = 2; i <= l; i++){
      if( deg(I[i]) != d ){
	ERROR("Ideal generators do not have equal degree ... quit.");
      }
    }
//     list L = trophials_monomials(n,d);
    matrix C[l][size(L)];
    poly f;
    for( j = 1; j <= l; j++){
      f = I[j];
      while( f != 0 ){
	for(k = 1; k <= size(L); k++){
	  if( leadexp(f) == L[k] ){
	    C[j,k] = leadcoef(f);
	    f = f - lead(f);
	  }
	}
      }
    }
    return(C);
  }
  if( l == 1 ){
//     d = deg(I[1]);
//     list L = trophials_monomials(n,d);
    matrix C[l][size(L)];
    poly f;
    for( j = 1; j <= l; j++){
      f = I[j];
      while( f != 0 ){
	for(k = 1; k <= size(L); k++){
	  if( leadexp(f) == L[k] ){
	    C[j,k] = leadcoef(f);
	    f = f - lead(f);
	  }
	}
      }
    }
    return(C);
  }
}						/* RETURN: Coefficient matrix with respect to all monomials in n variables of degree d */
static proc trophials_basis_helper(int deep,int max,intvec v,int pos,list L){	/* Helper for trophials_basis */
	if( deep > 0 ){
		for(int i = pos; i <= max - deep + 1; i++){
			v[size(v)-deep+1] = i;
			L = trophials_basis_helper(deep-1,max,v,i+1,L);
		}
		return(L);
	}
	if( deep == 0 ){
		L = reverse(insert(reverse(L),v));
		return(L);
	}
}
proc trophials_basis(matrix A){			/* INPUT: Matrix A */
  int r = rank(A);
  int n = ncols(A);
  intvec v = 1..r;
  list L;
  list combs = trophials_basis_helper(r,n,v,1,L);
  intvec rows = 1..r;
  list S;
  int k = 1;
  for(int i = 1; i <= size(combs); i++){
    if( rank(submat(A,v,combs[i])) == r ){
      S = reverse(insert(reverse(S),combs[i]));
      k = k + 1;
    }
  }
  return(S);
}						/* RETURN: list S containing bases of A saved as intvec */
proc trophials_complement(intvec v,int n){	/* INPUT: intvec v with entries in 1,...,n where the integer n is the second argument */
  if( trophials_max(v) <= n ){
    int i = 1;
    int k = size(v);
    int l = 1;
    intvec res;
    for(int j = 1; (j <= n); j++){
      if( i <= k ){
	if( j != v[i] ){
	  res[l] = j;
	  l = l + 1;
	}else{
	  i = i + 1;
	}
      }else{
	res[l] = j;
	l = l + 1;
      }
    }
    return(res);
  }else{
    ERROR("Something is wrong ...");
  }
}						/* RETURN: complement of v in 1,...,n */
// Conversion functions
static proc trophials_list_to_matrix(list L){	/* INPUT: list L containing support */
  int m = size(L);
  int n = size(L[1]);
  matrix A[m][n];
  int i,j;
  for(i = 1; i <= m; i++){
    for(j = 1; j <= size(L[i]); j++){
      A[i,j] = L[i][j];
    }
  }
  return(A);
}						/* RETURN: matrix containing affine support */
static proc SMatrixToPMatrix(string name,matrix B){	/* INPUT: string for name, matrix B */
  string res;
  int i,j;
  int n = ncols(B);
  int m = nrows(B);
  res = "$"+name+"= new Matrix<Rational>([";
  for(i = 1; i<= m; i++){
    res = res + "[";
    for(j = 1; j <= n; j++){
      res = res + string(B[i,j])+",";
    }
    res = res[1,size(res)-1] + "],";
  }
  res = res[1,size(res)-1]+"]);";
  return(res);
}						/* RETURN: string for polymake */
static proc SListToPArray(string name, list L){	/* INPUT: list L */
  int i,j;
  int n = size(L);
  string res = "$"+name+" = new Array<Set<Int>>(";
  int k = size(L[1]);
  res = res+"[";
  for(i = 1; i <= n; i++)
  {
    res = res+"[";
    for(j = 1; j <= k; j++)
    {
      res = res + string(L[i][j]-1)+",";
    }
    res = res[1,size(res)-1] +"],";
  }
  res = res[1,size(res)-1]+"]);";
  return(res);
}						/* RETURN: string for polymake */
static proc trophials_max(intvec v){			/* INPUT: intvec v */
  if( size(v) >= 2){
    int k = v[1];
    for(int i = 2; i <= size(v); i++){
      if( v[i] > k ){
	k = v[i];
      }
    }
  }else{
    return(v[1]);
  }
  return(k);
}						/* RETURN: maximum element of v */

// Formerly used:
// proc trophials_setup(int n, int d,string s){		/* INPUT: number of variables n, degree d, term ordering */
// 	ring r = basering;
// 	int i,j,k;
// 	string S = trophials_internal(n,d,s);
// 	execute(S);
// 	poly l = 0;
// 	poly f = 0;
// 	poly g = 1;
// 	for(i = 1; i <= n; i++){
// 		l = l + a(i)*x(i);
// 	}
// 	list L = trophials_monomials(n,d);
// 	for( i = 1; i <= size(L); i++){
// 		f = f + trophials_monom(L[i],2);
// 	}
// 	ideal I = l,f;
// 	keepring(R);
// }						/* RETURN: sets the basering */
// proc trophials_ideal{				/* INPUT: lists L_1,...,L_k (representing linear forms), L (representing polynomial) */
// 	
// 	int n = nvars(basering) - 2;
// 	int d = deg(I);
// 	
// 	list monomials_d = trophials_monomials(n,d);
// 	list monomials_d_1 = trophials_monomials(n,d-1);
// 	int n_mon = size(monomials_d);
// 	int n_forms = size(#) - 1;		// number of linear forms
// 	int i,j;
// 	ideal J,K;
// 
// 	
// 	
// 	for(i = 1; i <= size(#) - 1; i++){
// 		if( size(#[i]) != n ){
// 			print("Something is wrong ... the linear form"),i,print("needs"),n,print("coefficients.");
// 			ERROR("Please try again ...");
// 		}else{
// 			J = J + trophials_linearform(#[i]);
// 		}
// 	}
// 
// 	if( size(#[size(#)]) != n_mon ){
// 		print("Something is wrong ... the polynomial needs"),n_mon,print("coefficients.");
// 		ERROR("Please try again ...");
// 	}else{
// 		J = J + trophials_polynomial(#[size(#)]);
// 	}
// 	
// 	if( size(primdecGTZ(J)) != 1 ){
// 		print("ATTENTION: ideal I is not prime!");
// // 		primdecGTZ(J);
// 	}
// 	list R;
// 	R[1] = J;
// // 	print(J);
// 
// 	for(i = 1; i <= size(J) - 1; i++){
// 		for(j = 1; j <= size(monomials_d_1); j++){
// 			K = K + J[i]*trophials_monom(monomials_d_1[j],1);
// 		}
// 	}
// 	K = K + J[size(J)];
// 	R[2] = K;
// 
// 	return(R);
// }						/* RETURN: list[1]:original ideal,list[2]: ideal I generated by all shifted linear forms + polynomial */
// static proc trophials_linearform(list L){		/* INPUT: list L containing coefficients of linear form */
// 	int n = size(L);
// 	string s = "poly lf = subst(l,";
// 	for(int i = 1; i <= n - 1; i++){
// 		s = s + string("a(")+string(i)+string("),")+string(L[i])+",";
// 	}
// 	s = s + string("a(")+string(i)+string("),")+string(L[i])+string(");");
// 	execute(s);
// 	return(lf);
// }						/* RETURN: linear form */
// static proc trophials_polynomial(list L){		/* INPUT: list L containing coefficients of polynomial f */
// 	int n = size(L);
// 	string s = "poly res = subst(f,";
// 	list monomials = trophials_monomials(size(variables(I)),deg(I));
// 	for(int i = 1; i <= n - 1; i++){
// 		s = s + trophials_monom(monomials[i],4) + "," + string(L[i]) + ",";
// 	}
// 	s = s + trophials_monom(monomials[n],4) + "," + string(L[n]) + string(");");
// 	execute(s);
// 	return(res);
// }						/* RETURN: polynomial f */
// 						/* RETURN: list of all monomial vectors in n variables of degree d */
// proc trophials_monomials_x(list L, int k){		/* INPUT: list of monomial vectors, specified variable */
// 	intvec R;
// 	int n = size(L);
// 	int i,j;
// 	int l = 1;
// 	if( (n <= 0) || (size(L[1]) < k) ){
// 		print("Something is wrong with the input ... quit.");
// 	}
// 	for(i = 1; i <= n; i++){
// 		if( L[i][k] > 0 ){
// 			R[l] = i;
// 			l++;
// 		}
// 	}
// 	return(R);
// }						/* RETURN: intvec of indices whose corresponding monomials contain the variable k */
// proc trophials_example{				/* INPUT: n,d,a_1,...,a_n,b(d)(..)(0),...,b(0)(..)(d) */
// 
// 	list R = trophials_ideal(#);  							// Create ideal from input lists
// 
// 	ideal I_lin_part;								// I_lin_part = ideal generated by linear forms
// 	ideal I = R[1];									// I = ideal generated by linear forms and a polynomial
// 	
// 	
// 	/* --------------------------------------- */
// 	print("-----------------");
// 	print("Example for gfan:");
// 	print("-----------------");
// 	trophials_gfan_internal(I);
// 	print("-----------------");
// 	/* --------------------------------------- */
// 	
// 	
// // 	print("ideal gen. by linear forms and polynomial!");
// // 	print(I);
// 	
// 	list rel_rays;
// 	list rel_cones;
// 	list inj_cones;
// 	list lifted_rays;
// 	
// 	list resfan;
// 
// 	list inj;
// 
// 	int n = nvars(basering) - 2;							// n = number of variables 
// 	int d = deg(I);									// d = degree for shift
// 
// 	list mon = trophials_monomials(n,d);
// 	int i,j;
// 											// Compute the coefficient matrix of the linear part ...
// 	int n_lin = size(I) - 1;							// n_lin = #(linear forms of I)
// 	for(i = 1; i <= n_lin; i++){
// 		I_lin_part = I_lin_part + I[i];
// 	}
// 	matrix A = trophials_coefmat(I_lin_part);
// 
// // 	print(A);
// 											// Check error conditions!
// 	if( n - rank(A) != 3){
// 		ERROR("The linear space is not 2-dimensional!");
// 	}
// // 	print("---------");								// Check whether redundant linear forms exist ...
// 	if( rank(A) != size(#) - 1 ){
// 		ERROR("There are redundant linear forms!");
// 	}
// 
// 	list bases = trophials_basis(A);							// Compute all bases of the coefficient matrix ...
// 	if( size(bases) ==  binomial(ncols(A),rank(A)) ){
// 		print("Uniform matroid!");
// 	}
// 
// 	list c_bases;									// Compute bases of the matroid ...
// 	for(i = 1; i <= size(bases); i++){
// 		c_bases[i] = trophials_complement(bases[i],n);
// 	}
// 
// 	string write_name =":w polymake_data_";
// // 	string read_name ="singular_data_";
// 	string read_name ="singular_data";
// 
// 	poly f;
// 	ideal E;
// 	intvec v;
// 	list S,f_supp,empty;
// 	int k = 1;
// // 	intvec shift;
// // 	for(int i = 1; i <= size(bases[1]); i++){
// // 		shift[i] = 1;
// // 	}
// 	int sys;
// 	int n_bases = size(trophials_monomials(n-size(bases[1]),d));				// n_bases = #(variablen im relativen support)
// 
// // 	print("Compute relative supports ...");						// Compute relative Newton polytopes ...
// 	for(i = 1; i <= size(bases); i++){
// 		print("... for basis"),c_bases[i];					// <--- print relative Newton polytopes!	
// 		E = elim(I,bases[i]);
// 		if( size(E) != 1 ){
// 			print("Something is wrong with basis"),c_bases[i];
// 			print("After elimination we obtain"),E;
// 			ERROR("Figure this out!");
// 		}
// 		
// 		f = E[1];
// 		k = 1;
// 		f_supp = empty;								// Compute Newton polytope of f_B
// 		while( size(f) ){
//  			v = trophials_shorten(leadexp(f));					// basering has two extra variables ...
// 			f_supp[k] = v;							// ... we need to get rid of them.
// 			k = k + 1;
// 			f = f - lead(f);
// 		}
// 		S[i] = f_supp;								// Save Newton polytope of f_B
// 		if( size(S[i]) == n_bases ){
// 			print("Full support!");								// <--- print relative Newton polytopes!
// 		}else{
// 			print(submat(trophials_list_to_matrix(S[i]),intvec(1..size(S[i])),c_bases[i]));	// <--- print relative Newton polytopes!
// 		}
// 	}
// 	
// 	
// 	
// 	for(i = 1; i <= size(S); i++){							// Save the data in "polymake_data_XY" ...
// // 		res = "use application \"tropical\"; use vars '$m','$n';$n = "+string(size(S))+";"+SMatrixToPMatrix("m",trophials_shift_matrix(submat(trophials_list_to_matrix(S[i]),intvec(1..size(S[i])),c_bases[i])));
// 		res = "use application \"tropical\"; use vars '$m';"+SMatrixToPMatrix("m",submat(trophials_list_to_matrix(S[i]),intvec(1..size(S[i])),c_bases[i]));
// 		write(write_name+string(i),res);
// 	}
// 	// Write bases to file //
// // 	print(c_bases);
// 	res = "use application \"matroid\"; use vars '$Bases','$n_elements'; "+SListToPArray("Bases",c_bases)+"$n_elements = "+string(n);
// 	write(write_name+"matroid",res);
// 	
// 	print("Starting polymake computations ...");
// 
// // 	ATTENTION!
// 	
// 	sys = system("sh","polymake --script trophials_pmscript10");				// polymake calculates all normal resfans  and saves data in "singular_data_XY"
// 	print("Done!");
// 
// 	execute(read(read_name));
// 	
// 	print("Rays:");
// 	print(rays);
// 	print("Lineality:");
// 	print(lineality);
// 	print("Weights:");
// 	print(weights);
// 	
// // 	ATTENTION!
// 	
// // 	print("Skipped all computations!");
// // 	for(i = 1; i <= size(S); i++){							// Read data, check for injectivity
// // 		inj = -1;
// // 		execute(read(read_name+string(i)));
// // 		rel_rays[i] = trophials_prim_gen(trophials_dehom(rays,ncols(rays)));
// // 		rel_cones[i] = cones;
// // 		for(j = 1; j <= size(cones); j++){
// // 			inj[j] = trophials_check_injective(submat(rel_rays[i],cones[j],intvec(1..ncols(rays)-1)));
// // 		}
// // 		inj_cones[i] = inj;
// // 	}
// // 	print("Compute lattice of flats...");
// // 	matrix B = transpose(syz(trophials_coefmat(I_lin_part)));						// Compute a Gale dual B (for the lattice of flats)
// // 	list lattice = lof(B);										// Compute lattice of flats
// // 	print("Lift cones...");
// // 	resfan = trophials_linear_lift(B,rel_rays,rel_cones,c_bases,lattice,inj_cones);			// Lift all cones according to the lattice of flats
// // 	
// // 	matrix lineality[1][ncols(resfan[1])];
// // 	for(i = 1; i <= ncols(resfan[1]); i++){
// // 		lineality[1,i] = 1;
// // 	}												// NOTE: Lineality Space disregarded so far! 
// // 	resfan[3] = lineality;
// 
// // 	/* --------------------------------------- */
// // 	print("-----------------");
// // 	print("Example for gfan:");
// // 	print("-----------------");
// // 	trophials_gfan_internal(I);
// // 	print("-----------------");
// // 	/* --------------------------------------- */
// // 	print("Rays:");
// // 	print(resfan[1]);
// // 	print("Cones:");
// // 	print(resfan[2]);
// // 	print("Lineality Space:");
// // 	print(resfan[3]);
// // 	SFanToPFan(resfan,"fan");									// Save fan for polymake
// // 	return(resfan);
// }						/* RETURN: computes the tropical variety */
// proc trophials_linear_lift(matrix B,list rays,list cones,list bases,list lattice,inj_cones){	/* INPUT: matrix A (Gale dual), list of lists of "local" rays */
// 	int i,j,k,l,n,counter,n_avoid,n_fans,base_size,flat_rank;
// 	list v_order;
// 	list v_order_lifted;
// 	list v_order_new;
// 	list v_data;
// 	list v_temp;
// 	list new_rays;
// 	list resfan;
// 	intvec indices,avoid;
// 	list res_cones;
// 
// 	n_fans = size(rays);
// 	base_size = size(bases[1]);
// 	
// // 	print("Lift weight classes ...");
// 	// At first we lift the rays with respect to the ambient linear space (regardless of the fact that some of them are non-injectively lifted)
// 
// 	for(i = 1; i <= n_fans; i++){						// Consider local fan i
// // 		print("fan:"),i;
// 		matrix lifted_rays[nrows(rays[i])][ncols(B)];			// New rays saved in lifted_rays in the following:
// 
// 		// Now we lift ray j to the ambient tropical linear space. Therefore we compute its weight class and apply the closure operator (w.r.t. the lattice of flats) //
// 		v_temp = 0;
// 		
// // 		print("rays:");
// // 		print(rays[i]);
// 		for(j = 1; j <= nrows(rays[i]); j++){				// Consider ray j of local fan i, compute sets of columns, sorted by value s.t. w_i_1 = w_i_2 <= w_i_3 = w_i_4 <= ... and (i_1,i_2)=1. set, (i_3,i_4)=2. set and so on.
// 			v_order = 0;
// // 			print("Consider ray"),j;
// 			v_order = trophials_ray_to_wc(submat(rays[i],intvec(j),intvec(1..ncols(rays[i]))));		// Compute weight class of ray j
// 
// 			for(k = 1; k <= size(v_order); k++){							// We worked with indices 1...rank(B), we have to switch to basis indices.
// 				v_order[k][2] = trophials_switch_indices_to_basis(v_order[k][2],bases[i]);
// 			}
// 
// 			v_order_lifted = trophials_lift_wc(v_order,lattice);						// Lift weight class according to lattice of flats (apply closure operator)
// 
// 			// NOTE: v_order_lifted contains the flag of flats !!! i.e. v_order[i][2] is subset of v_order[i+1][2]
// 
// 			v_order_new = 0;
// 			for(k = size(v_order_lifted); k >= 2; k--){										// Recursively remove predecessor to obtain weight class
// 				v_order_new[k] = list(v_order_lifted[k][1],trophials_remove_intvecs(v_order_lifted[k][2],v_order_lifted[k-1][2]));
// 			}
// 			v_order_new[1] = list(v_order_lifted[1][1],v_order_lifted[1][2]);							// The first set remains untouched.
// 
// 			for(k = 1; k <= size(v_order_new); k++){										// We can complete ray j in "lifted_matrix"
// 				for(l = 1; l <= size(v_order_new[k][2]); l++){
// 					lifted_rays[j,v_order_new[k][2][l]] = v_order_new[k][1];
// 				}
// 			}
// 
// 			// We are done with ray j //
// 
// 			v_temp[j] = list(v_order,v_order_new);			// Save local and global weight class data
// 		}
// 		v_data[i] = v_temp;						// v_data[i] = weight classes of rays of fan i
// // 		new_rays[i] = lifted_rays;
// // 		new_rays[i] = trophials_dehom(lifted_rays,bases[i][base_size]);	// dehomogenize rays of fan i w.r.t. last basis variable
// 		new_rays[i] = trophials_dehom(lifted_rays,ncols(lifted_rays));	// dehomogenize rays of fan i w.r.t. last basis variable
// 	}
// // 	print(v_data);
// // 	print("fan"),1,print("cone"),1;
// // 	print("injective:");
// // 	print(inj_cones[1]);
// // 	print("cone gen.:");
// // 	print(cones[1]);
// // 	print("rays:");
// // 	print(rays[1]);
// // 	print("v_data:");
// // 	print(v_data[1]);
// // 	for(int i = 1; i <= size(new_rays); i++){
// // 		print("rays"),i;
// // 		print(new_rays[i]);
// // 	}
// // 	print(lattice);
// 
// 	// Now we have to remove all non-injective cones
// 	// NOTE: RAYS --> list new_rays, CONES --> list cones, MATROID-BASES --> list bases, LATTICE --> list lattice, INJECTIVITY --> list inj_cones //
// 
// 	list checked_cones;
// 	intvec checked;
// 	int base_index;
// 
// 	for(i = 1; i <= size(cones); i++){
// 		checked = 0;
// 		for(j = 1; j <= size(cones[i]); j++){
// 			checked[j] = 0;
// 		}
// 		checked_cones[i] = checked;
// 	}
// 
// 	list bases_to_check;
// 	int global;
// 	n = ncols(new_rays[1]);
// 
// 	matrix R[1][n];
// 	list fan=list(R,list());
// 	for(i = 1; i <= size(cones); i++){				// Consider fan i,
// // 		print("i="),i;											// <-- good for DEBUG
// // 		print("rays:");
// // 		print(new_rays[i]);
// // 		print("cones:");
// // 		print(cones[i]);
// 		for(j = 1; j <= size(cones[i]); j++){			// consider its j-th cone.
// // 			// Cone j of fan i is mapped injectively!
// // 			print("cone j="),j;									// <-- good for DEBUG
// 			if( inj_cones[i][j][1] == 1 ){
// // 				print("injectively!");								// <-- good for DEBUG
// // 				print("add cone");								// <-- good for DEBUG
// // 				print(submat(new_rays[i],cones[i][j],intvec(1..n)));				// <-- good for DEBUG
// 				fan = trophials_add_cone_to_fan(fan[1],fan[2],submat(new_rays[i],cones[i][j],intvec(1..n)));
// 				checked_cones[i][j] = 1;
// 			}else{
// // 				print("not injectively!");							// <-- good for DEBUG
// // 			// Cone j of fan i is mapped NON-injectively, so check other projections
// 				bases_to_check = 0;
// 				v_order = 0;
// 
// // 				print("Cone");									// <-- good for DEBUG
// // 				print(submat(new_rays[i],cones[i][j],bases[i]));				
// 				R = trophials_inner_cone_point(submat(new_rays[i],cones[i][j],bases[i]));
// // 				print("interior point:");
// // 				print(R);
// 				v_order = trophials_ray_to_wc(R);
// // 				print("corresponding v_order:");
// // 				print(v_order);
// // 				print("Input for bases_to_check:");
// // 				print("inj_cones:");
// // 				print(inj_cones[i][j]);	
// 				bases_to_check = trophials_bases_to_check(i,inj_cones[i][j],lattice,v_order,bases);
// 
// // 				print("all bases:");								// <-- good for DEBUG
// // 				print(bases);									// <-- good for DEBUG
// // 				print("bases to check:");							// <-- good for DEBUG
// // 				print(bases_to_check);								// <-- good for DEBUG
// 				global = 1;
// 				for(k = 1; k <= size(bases_to_check); k++){
// 					if( bases_to_check[k] != bases[i] ){
// 						base_index = 0;
// 						base_index = trophials_find_basis_index(bases_to_check[k],bases);
// 						if( base_index != 0 ){
// // 							print("base_index:"),base_index;
// 							if( !trophials_check_for_cone(new_rays[base_index],cones[base_index],submat(new_rays[i],cones[i][j],intvec(1..n))) ){
// 								global = 0;
// 								
// 							}
// 						}
// 					}
// 				}
// 				if( global == 0 ){
// // 					print("does not exist globally!");
// 					j++;
// 					continue;
// 				}else{
// // 					print("add cone");
// // 					print(submat(new_rays[i],cones[i][j],intvec(1..n)));
// 					fan = trophials_add_cone_to_fan(fan[1],fan[2],submat(new_rays[i],cones[i][j],intvec(1..n)));
// 				}
// 			}
// // 			print("current:");									// <-- good for DEBUG
// // 			print(fan[1]);										// <-- good for DEBUG
// // 			print(fan[2]);										// <-- good for DEBUG
// 				
// 		}
// // 		print("After i ="),i;
// // 		print(fan[1]);
// // 		print(fan[2]);
// 	}
// 	return(fan);
// }											/* RETURN: list of lifted rays with respect to linear space */
// proc trophials_find_basis_index(intvec base,list bases){					/* INPUT: certain base, list of bases */
// for(int i = 1; i <= size(bases); i++){
// 	if( bases[i] == base ){
// 		return(i);
// 	}
// }
// return(0);
// }											/* RETURN: index of base in list bases */
// proc trophials_bases_to_check(int i,list injectivity,list lattice,list v_order,list bases){
// 	intvec set,set_flat;
// 	intvec set_l,set_l_flat;
// 	intvec set_r,set_r_flat;
// 	intvec comp;
// // 	list v_data;
// 	list bases_to_check;
// 	int j,k,l,counter;
// 	intvec base = bases[i];
// // 	print("weight class:");
// // 	print(v_order);
// 
// 	intvec equals,base_left;
// 
// 	if( injectivity[1] == 0 ){	// Standard-hyperplane
// 		equals[1] = base[injectivity[2]];
// 		equals[2] = base[size(bases[i])];
// 	}
// 
// 	if( injectivity[1] == 2 ){	// x_i = x_j
// 		equals[1] = base[injectivity[2]];
// 		equals[2] = base[injectivity[3]];
// 	}
// // 	print("basis:");
// // 	print(bases[i]);
// // 	print("equals =");
// // 	print(equals);
// // 	print("before:");
// // 	print(v_order);
// 	for(j = 1; j <= size(v_order); j++){
// 		v_order[j][2] = trophials_switch_indices_to_basis(v_order[j][2],base);
// 	}
// // 	print("v_order:");
// // 	print(v_order);
// 	
// 	for(j = 1; j <= size(v_order); j++){
// 		if( !trophials_contains(v_order[j][2],equals[1]) ){			// If v_order[2] does NOT contain an "equal" ...
// 			if( j == 1 ){
// 				set = v_order[j][2];
// 			}else{
// 				set = trophials_merge_intvecs(set,v_order[j][2]);
// 			}
// 		}else{
// 			if( j == 1 ){
// 				set_l = equals[1];
// 				set_r = equals[2];
// 				set = equals;
// 				break;
// 			}else{
// 				set_l = trophials_merge_intvecs(set,equals[1]);
// 				set_r = trophials_merge_intvecs(set,equals[2]);
// 				set = trophials_merge_intvecs(set_l,set_r);
// 				break;
// 			}
// 		}
// 	}
// 	set_l = trophials_sort_intvec(set_l);
// 	set_r = trophials_sort_intvec(set_r);
// // 	print("Both sets:");
// // 	print(set_l);
// // 	print("----");
// // 	print(set_r);
// // 	print("set:");
// // 	print(set);
// 	
// 	set_l_flat = trophials_search_flat(set_l,lattice[size(set_l)]);
// 
// 	set_r_flat = trophials_search_flat(set_r,lattice[size(set_r)]);
// 	
// 	set_flat = trophials_search_flat(set,lattice[size(set)]);
// // 	print("Both flats:");
// // 	print(set_l_flat);
// // 	print("----");
// // 	print(set_r_flat);
// // 	print("set flat:");
// // 	print(set_flat);
// 	if( trophials_merge_intvecs(set_l_flat,set_r_flat) == set_flat ){
// 		return(base);
// 	}else{
// 		counter = 1;
// 		comp = trophials_remove_intvecs(set_flat,trophials_merge_intvecs(set_l_flat,set_r_flat));
// // 		print("comp:");
// // 		print(comp);
// 		comp = trophials_merge_intvecs(comp,equals);
// // 		print("comp filled:");
// // 		print(comp);
// 		for(k = 1; k <= size(comp)-1; k++){
// 			for(l = k + 1; l <= size(comp); l++){
// 				base_left = trophials_remove_intvecs(base,equals);
// 				bases_to_check[counter] = trophials_merge_intvecs(trophials_merge_intvecs(base_left,intvec(comp[k])),intvec(comp[l]));
// 				counter++;
// 			}
// 		}
// 		return(bases_to_check);
// 	}
// }										/* RETURN: intvec indices corresponding to bases to check */
// proc trophials_add_cone_to_fan(matrix res_rays,list res_cones,matrix cone_generators){	/* INPUT: fan (res_rays,res_cones) and new cone "cone_generators" */
// 	int index = 0;
// 	int k;
// 	list new_cones;
// 	intvec new_cone_indices = 0;
// 	matrix comb_rays = res_rays;
//   
// 	if( size(res_cones) == 0 ){						// Fan is empty
// 		return(list(cone_generators,intvec(1..nrows(cone_generators))));
// 	}else{
// 		if( !trophials_check_for_cone(res_rays,res_cones,cone_generators) ){		// If cone is not contained in res_fan ...
// 			for(k = 1; k <= nrows(cone_generators); k++){
// 				index = trophials_check_for_ray(res_rays,submat(cone_generators,intvec(k),intvec(1..ncols(cone_generators))));	// Is ray new_ray[i][k] contained?
// 				if( !index ){
// 					comb_rays = transpose(concat(transpose(comb_rays),transpose(submat(cone_generators,intvec(k),intvec(1..ncols(cone_generators))))));
// 					new_cone_indices[k] = nrows(comb_rays);
// 				}else{
// 					new_cone_indices[k] = index;
// 				}
// 			}
// 			new_cones = res_cones;
// 			new_cones = insert(new_cones,new_cone_indices,size(new_cones));
// 			return(list(comb_rays,new_cones));
// 		}else{
// 			return(list(res_rays,res_cones));
// 		}
// 	}
// }											/* RETURN: new fan with new cone properly added (i.e. check whether rays already exist in old fan etc.) */
// proc trophials_lift_wc(list v_order,list lattice){						/* INPUT: weight class (output of trophials_ray_to_wc and trophials_switch_indices_to_basis) */
// 	list v_order_lifted = 0;									// We apply the closure operator now.
// 	int flat_rank = size(v_order[1][2]);
// 	int k;
// 	intvec indices = v_order[1][2];									// First flat to lift (i.e. apply closure operator)
// 	v_order_lifted[1] = list(v_order[1][1],trophials_search_flat(v_order[1][2],lattice[flat_rank]));
// 
// 	for(k = 2; k <= size(v_order); k++){
// 		indices = trophials_merge_intvecs(indices,v_order[k][2]);					// Add new set (basis variables)
// 		flat_rank = size(indices);								// Update the flat_rank
// 		v_order_lifted[k] = list(v_order[k][1],trophials_search_flat(indices,lattice[flat_rank]));	// Find the flat of the just defined set
// 	}
// return(v_order_lifted);									/* RETURN: lifted weight class */
// }											/* RETURN: list=(1. value, 2. indices) */
// proc trophials_ray_to_wc(matrix ray){							/* INPUT: matrix ray */
// 	int k;
// 	int n = ncols(ray);		// Maximum number of columns
// 	int n_avoid = 0;		// Number of columns we have to avoid (reseted to 0 here)
// 	int counter = 1; 		// Reset counter that counts the number of different sets according to the values
// 	intvec indices = 0;
// 	intvec avoid = 0;
// 	list v_order = 0;		// Reset v_order
// 	while( n - n_avoid > 0 ){	// As long as there are remaining columns do ...
// 		indices = 0;									// Reset indices (=0)
// 		indices = trophials_min_indices(submat(ray,intvec(1),intvec(1..n)),avoid);		// find new min value and its indices.
// 		if( n_avoid == 0 ){								// If this is the first round ...
// 			avoid = indices;							// ... avoid the just found indices in the next round.
// 		}else{										// ... Otherwise add them.
// 			for(k = 1; k <= size(indices); k++){					// ... by attaching them to the end of "avoid" ...
// 				avoid[n_avoid + k] = indices[k];
// 			}
// 		}
// 		avoid = trophials_sort_intvec(avoid);						// Sort avoid (important for "trophials_min_indices"!)
// 		v_order[counter] = list(ray[1,indices[1]],indices);				// v_order[i] = 1. value, 2. indices of i-th step
// 		counter = counter + 1;								// We found a new set, so increase "counter" by 1
// 		n_avoid = size(avoid);								// Avoid more columns (see while condition)
// 	}
// 	return(v_order);
// }											/* RETURN: list of indices sorted by value (from min to max value of ray) */
// proc trophials_switch_indices_to_basis(intvec set,intvec basis){	/* INPUT: indices "set" = i_1,i_2,...,i_n, basis b */
// 	intvec res;
// 	int i;
// 	for(i = 1; i <= size(set); i++){
// 		res[i] = basis[set[i]];
// 	}
// 	return(res);
// }								/* RETURN: intvec v = (b(i_1),b(i_2),...,b(i_n)) */
// proc trophials_search_flat(intvec set,list flats){			/* INPUT: set of variables, list of flats */
// int k = size(set);
// int counter = k;
// int i;
// 	for(i = 1; i <= size(flats); i++){
// 		counter = k;
// 		while( counter > 0 ){
// 			if( trophials_contains(flats[i],set[k-counter+1]) ){
// 				counter--;
// 			}else{
// 				counter = -1;
// 			}
// 		}
// 		if( counter == 0 ){
// 			return(flats[i]);
// 		}
// 	}
// 	print("No flat found.");
// 	print("set:");
// 	print(set);
// 	print("flats:");
// 	print(flats);
// }								/* RETURN: flat containing the set */
// proc trophials_min_indices(matrix A,intvec avoid){			/* INPUT: 1xn matrix A, intev with indices to avoid */
// 	int i,counter;
// 	number min_value = 100;
// 	intvec indices;
// 	int last_min;
// 	intvec complement = trophials_complement(avoid,ncols(A));
// // 	print("consider columns:"),complement;
// // 	print("complement"),complement;
// 	
// 	for(i = 1; i <= ncols(A); i++){				// Sum abs values of components of A, definitely bigger than each component.
// 		min_value = min_value + number(absValue((A[1,i])));
// 	}
// // 	print("min_value:"),min_value;
// // 	print("avoid:"),avoid;
// 
// 	for(i = 1; i <= size(complement); i++){	// find a min value w.r.t. avoid
// // 		print("Consider column"),i;
// // 		print("compare"),number(A[1,complement[i]]),print("and"),min_value;
// 		if( (A[1,complement[i]]) < min_value ){
// // 			print("if you see this, left is smaller.");
// // 			print(number(A[1,i])),print("is smaller than"),print(min_value);
// 			min_value = number(A[1,complement[i]]);
// 			counter = 1;
// 			indices = 0;
//  			indices[counter] = complement[i];
// 			counter++;
// 			last_min = complement[i];
// // 			print("indices with min value:"),indices;
// 		}
// 		if( number(A[1,complement[i]]) == min_value && (last_min != complement[i])	 ){
// // 			print("equality, but different index!");
// 			indices[counter] = complement[i];
// 			counter++;
// 		}
// // 		print("next i:");
// // 		print(i),print("<="),print(ncols(A)),print("?, and"),print("is"),i+1,print("contained in"),avoid,print("?");
// 	}
// // 	print("min indices:");
// // 	print(indices);
// 	return(indices);
// }								/* RETURN: columns of A with minimal value according to allowed columns (w.r.t. avoid) */
// proc trophials_sort_intvec(intvec v){		/* INPUT: intvec v */
// 	int i,n,c;
// 	for(n = size(v); n > 1; n = n - 1){
// 		for(i = 1; i < n; i = i + 1){
// 			if( v[i] > v[i + 1] ){
// 				c = v[i];
// 				v[i] = v[i+1];
// 				v[i+1] = c;
// 			}
// 		}
// 	}
// 	return(v);
// }						/* RETURN: sorted intvec v */
// static proc trophials_internal(int n, int d,string s){	/* INPUT: number of variables n, degree d */
// 	list L = trophials_monomials(n,d);
// 	
// 	string coefs = "ring R = (0,a(1.."+string(n)+string("),");;
// 	int i,j;
// 	for( i = 1; i <= size(L); i++){
// 		coefs = coefs + "b(";
// 		j = 1;
// 		while( j <= n - 1 ){
// 			coefs = coefs + string(L[i][j]) + ")(";
// 			j = j + 1;
// 		}
// 		coefs = coefs + string(L[i][n]) + ")";
// 		if( i != size(L) ){
// 			coefs = coefs + ",";
// 		}else{
// 			coefs = coefs + "),";
// 		}
// 	}
// 	coefs = coefs + string("(x(1..")+string(n)+"),x,y),"+s+";";
// 	return(coefs);
// }							/* RETURN: string of coefficients */
// proc trophials_monom(intvec v,int b){		/* INPUT: */
// 	int i = 1;
// 	if( b == 1 ){
// 		poly g = 1;
// 		while( i <= size(v) ){
// 			g = g*x(i)^v[i];
// 			i = i + 1;
// 		}
// 		return(g);
// 	}
// 	if( b == 0 ){
// 		string str = string("poly f = b(");
// 		for( i = 1; i <= size(v) - 1; i++){
// 			str = str + string(v[i]) + ")(";
// 		}
// 		str = str + string(v[size(v)]) + ")";
// 		execute(str);
// 		return(f);
// 	}
// 	if( b == 2){
// 		string str = string("poly res = b(");
// 		for( i = 1; i <= size(v) - 1; i++){
// 			str = str + string(v[i]) + ")(";
// 		}
// 		str = str + string(v[size(v)]) + ")";
// 		execute(str);
// 		poly g = 1;
// 		i = 1;
// 		while( i <= size(v) ){
// 			g = g*x(i)^v[i];
// 			i = i + 1;
// 		}
// 		return(res*g);
// 	}
// 	if( b == 4 ){
// 		string str = string("b(");
// 		for( i = 1; i <= size(v) - 1; i++){
// 			str = str + string(v[i]) + ")(";
// 		}
// 		str = str + string(v[size(v)]) + ")";
// 		return(str);
// 	}
// }						/* RETURN: Term b(v)*x^v */
// 							/* RETURN: */
// proc trophials_contains(intvec v,int i){		/* INPUT: integer vector v, integer i */
// 	for(int j = 1; j <= size(v); j++){
// 		if( v[j] == i ){
// 			return(1);
// 		}
// 	}
// 	return(0);
// }						/* RETURN: boolean; checks whether v contains i or not */
// proc trophials_merge_intvecs(intvec v1,intvec v2){	/* INPUT: two intvecs v1,v2 */
// 	int l1 = size(v1);
// 	int l2 = size(v2);
// 	int pos1 = 1;
// 	int pos2 = 1;
// 	intvec res;
// 	int step = 1;
// 	
// 	while( pos1 <= l1 && pos2 <= l2 ){
// 		if( v1[pos1] == v2[pos2] ){
// 			res[step] = v1[pos1];
// 			pos1 = pos1 + 1;
// 			pos2 = pos2 + 1;
// 			step = step + 1;
// 			continue;
// 		}
// 		if( v1[pos1] < v2[pos2] ){
// 			res[step] = v1[pos1];
// 			pos1 = pos1 + 1;
// 			step = step + 1;
// 			continue;
// 		}
// 		if( v1[pos1] > v2[pos2] ){
// 			res[step] = v2[pos2];
// 			pos2 = pos2 + 1;
// 			step = step + 1;
// 			continue;
// 		}
// 		res;
// 	}
// 	if( pos1 <= l1 ){
// 		for(int i = pos1; i <= l1; i++){
// 			res[step] = v1[i];
// 			step = step + 1;
// 		}
// 	}
// 	if( pos2 <= l2 ){
// 		for(int i = pos2; i <= l2; i++){
// 			res[step] = v2[i];
// 			step = step + 1;
// 		}
// 	}
// 	return(res);
// }						/* OUTPUT: union of v1 and v2 */
// proc trophials_remove_intvecs(intvec v1,intvec v2){	/* INPUT two intvecs v1,v2 */
// 	intvec res;
// 	int counter = 1;
// 	for(int i = 1; i <= size(v1); i++){
// 		if( trophials_contains(v2,v1[i]) ){
// 			i++;
// 			continue;
// 		}else{
// 			res[counter] = v1[i];
// 			counter++;
// 		}
// 	}
// 	return(res);
// }						/* RETURN: v1 minus v2 */
// static proc trophials_gfan_internal(ideal I){	/* INPUT: ideal I (generated by trophials_example) */
// 	int n = nvars(basering) - 2;
// 	int i;
// 	list vars;
// 	poly f = 0;
// 	if( n > 26 ){
// 		ERROR("Too much variables (more than 26). Quit!");
// 	}
// 	vars = "a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z";
// 	string gfan_ring = "Q[";
// 	for( i = 1; i <= n - 1; i++){
// 		  gfan_ring = gfan_ring + vars[i] + ",";
// 	}
// 	gfan_ring = gfan_ring + vars[n] + "]";
// 	string gfan_poly = string("{");
// 	
// 	for(int j = 1; j <= size(I) - 1; j++){
// 		f = I[j];
// 		while( deg(f) != -1 ){
// 			gfan_poly = gfan_poly + string(leadcoef(f));
// 			for( i = 1; i <= size(leadexp(f)); i++){
// 				if( leadexp(f)[i] > 0 ){
// 					gfan_poly = gfan_poly + vars[i] + string(leadexp(f)[i]);
// 				}
// 			}
// 			if( deg(f-lead(f)) != -1 ){
// 				gfan_poly = gfan_poly + "+";
// 			}
// 			
// 			f = f - lead(f);
// 		}
// 		gfan_poly = gfan_poly + ",";
// 	}	
// 	f = I[size(I)];
// 	while( deg(f) != -1 ){
// 		gfan_poly = gfan_poly + string(leadcoef(f));
// 		for( i = 1; i <= size(leadexp(f)); i++){
// 			if( leadexp(f)[i] > 0 ){
// 				gfan_poly = gfan_poly + vars[i] + string(leadexp(f)[i]);
// 			}
// 		}
// 		if( deg(f-lead(f)) != -1 ){
// 			gfan_poly = gfan_poly + "+";
// 		}
// 		f = f - lead(f);
// 	}
// 	gfan_poly = gfan_poly + string("}");
// 	print(gfan_ring);
// 	print(gfan_poly);
// }						/* RETURN: output for gfan, containing the first and last generator of I */
// 
// 
// 
// proc trophials_max(intvec v){			/* INPUT: intvec v */
// if( size(v) >= 2){
// 	int k = v[1];
// 	for(int i = 2; i <= size(v); i++){
// 		if( v[i] > k ){
// 			k = v[i];
// 		}
// 	}
// }else{
// 	return(v[1]);
// }
// return(k);
// }						/* RETURN: maximum element of v */
// proc trophials_check_injective(matrix rays){		/* INPUT: matrix containing rays generating a cone */
// // 	print("rays to check:");
// // 	print(rays);
// 	matrix linear_span_rays = rowred(transpose(syz(rays)));
// 	int i;
// // 	print("linear space:");
// // 	print(linear_span_rays);
// 	int p_counter = 0;
// 	int m_counter = 0;
// 	intvec p_locus;
// 	intvec m_locus;
// 
// 	if( nrows(linear_span_rays) != 1 ){
// 		print("cone:");
// 		print(rays);
// 		print("kernel:");
// 		print(linear_span_rays);
// 		ERROR("Something is wrong with the linear space spanned by the cone generators!");
// 	}
// 
// 	for(i = 1; i <= ncols(linear_span_rays); i++){
// 		if( linear_span_rays[1,i] > 0 ){
// 			p_counter++;
// 			p_locus[p_counter] = i;
// 		}
// 		if( linear_span_rays[1,i] < 0 ){
// 			m_counter++;
// 			m_locus[m_counter] = i;
// 		}
// 	}
// // 	if( (m_counter == 0 && p_counter == 1) || (m_counter == 1 && p_counter == 0) || (m_counter == 1 && p_counter == 1) ){		// FALSCHE BEDINGUNGEN!!!!
// // 		print("Probably not injective!");
// // 		return(list(0,p_locus,m_locus));
// // 	}else{
// // 		print("Definitely injective!");
// // 		return(list(1,p_locus,m_locus));
// // 	}
// 	if( (m_counter == 0 && p_counter == 1) || (m_counter == 1 && p_counter == 0) ){
// // 		print("condition 1");
// 		return(list(0,p_locus,m_locus,linear_span_rays));
// 	}
// 	if( (m_counter == 1 && p_counter == 1) ){
// 		if( linear_span_rays[1,p_locus[1]] + linear_span_rays[1,m_locus[1]] == 0 ){
// // 			print("condition 2");
// 			return(list(2,p_locus,m_locus,linear_span_rays));
// 		}
// 	}
// // 	print("condition 3");
// 	return(list(1,p_locus,m_locus,linear_span_rays));
// }						/* RETURN: list = (1. bool (1=injective, 0=non-inj. (standard-hyperplane), 2=non-inj. (x_i=x_j)), 2. intvec p_locus with indices >0, 3. intvec m_locus with indices <0) */
// proc trophials_dehom(matrix A,int k){		/* INPUT: matrix A, integer k ASSUMPTION: lineality space = (1,...,1) */
// matrix B = A;
// int i,j;
// for(i = 1; i <= nrows(B); i++){
// // 	print("row"),i;
// // 	print("value:"),B[i,k];
// 	if(B[i,k] != 0){
// // 		print("true!");
// 		for(j = 1; (j <= ncols(B)); j++ ){
// // 			print("column"),j;
// // 			print("old:"),print(B[i,j]);
// 			B[i,j] = B[i,j]-A[i,k];
// // 			print("new:"),print(B[i,j]);
// 		}
// 		B[i,k] = 0;
// 	}
// }
// return(B);
// }						/* RETURN: matrix A' with rows shifted s.t. (A')_k = 0 for all rows */
// proc trophials_prim_gen(matrix A){			/* INPUT: matrix A (rays) */
// 	int denom_counter = 1;
// 	intvec denom;
// 	int i,j;
// 	number res_gcd = 1;
// 	int res_lcm = 1;
// 
// 	matrix B = A;
// 	matrix C = A;
// 	for(i = 1; i <= nrows(A); i++){
// 		denom_counter = 1;
// 		for(j = 1; j <= ncols(A); j++){
// 		      if( A[i,j] != 0 ){
// 			      denom[denom_counter] = int(denominator(number(A[i,j])));
// 			      denom_counter++;
// 		      }
// 		}	
// 		res_lcm = lcm(denom);
// 		C = multrow(B,i,absValue(res_lcm));
// 		B = C;
// 	}
// 	if( ncols(A) >= 2 ){
// 		for(i = 1; i <= nrows(A); i++){
// 			res_gcd = number(gcd(number(A[i,1]),number(A[i,2])));
// 			for(j = 3; j <= ncols(A); j++){
// 				res_gcd = number(gcd(number(res_gcd),number(A[i,j])));
// 			}
// // 			print("gcd for"),i,print("-th column:"),res_gcd;
// 			C = multrow(B,i,1/absValue(res_gcd));
// 			B = C;
// 		}
// 	}else{
// 		for(i = 1; i <= nrows(A); i++){
// 			res_gcd = number(gcd(number(A[i,1]),number(A[i,2])));
// 			C = multrow(B,i,1/absValue(res_gcd));
// 			B = C;
// 		}
// 	}
// 	return(B);
// }						/* RETURN: matrix A' (cleared denominator) */
// proc trophials_check_for_cone(matrix rays,list cones,matrix cone_generators){	/* INPUT: rays of a fan, cones of a fan, matrix representing a cone */
// 	int res = 0;
// 	int i;
// 	matrix A[size(cones[1])][ncols(rays)];
// 	for(i = 1; i <= size(cones); i++){
// 		A = submat(rays,cones[i],intvec(1..ncols(rays)));
// 		res = trophials_compare_cones(A,cone_generators);
// 		if( res == 1 ){
// 			return(res);
// 		}
// 	}
// 	return(res);
// }										/* RETURN: bool (1=yes, is contained, 0=no, does not exist) */
// proc trophials_compare_cones(matrix A,matrix B){	/* INPUT: two cones generated by rows of matrices */
// 	int i,j,k;
// 	int found = 0;
// 	matrix C[2][ncols(A)];
// 	if( nrows(A) != nrows(B) ){
// 		print("Cones have unequal number of generators.");
// 		return(0);
// 	}
// 	intvec used = 0;
// 	i = 1;
// 	while( i <= nrows(A) ){
// 	// 	print("Aktuell i ="),i;
// 		found = 0;
// 		C[1,1..ncols(A)] = submat(A,intvec(i),intvec(1..ncols(A)));
// 		j = 1;
// 		while( j <= nrows(B) && found == 0){
// 			if( !trophials_contains(used,j) ){
// 				C[2,1..ncols(A)] = submat(B,intvec(j),intvec(1..ncols(B)));
// 				if( rank(C) == 1 ){
// 					for(k = 1; k <= ncols(C); k++){
// 						if( C[1,k] != 0 && C[2,k] != 0 ){
// 							if( C[1,k]/C[2,k] > 0 ){
// 								used[i] = j;
// // 								print("found, j ="),j;
// 								found = 1;
// 								i++;
// 								k = ncols(C) + 1;
// 								continue;
// 							}
// 						}
// 					}
// 				}
// 			}
// 			j++;
// 		}
// 		
// 		if( found == 0 ){
// //			print("ray"),i,print("has no partner.");
// 			return(0);
// 		}
// 	}
// 	return(1);
// }						/* RETURNS: bool (1=yes, cones are equal, 0=no, cones are unequal */
// proc trophials_check_for_ray(matrix rays, matrix ray){	/* INPUT: matrix rays, matrix ray */
// 	int i,j;
// 	for(i = 1; i <= nrows(rays); i++){												// Consider i-th ray
// 		if( rank(transpose(concat(transpose(submat(rays,intvec(i),intvec(1..ncols(rays)))),transpose(ray)))) == 1 ){		// Check rank
// 			for(j = 1; j <= ncols(rays); j++){
// 				if( rays[i,j] != 0 && ray[1,j] != 0 ){									// Check the sign
// 					if( rays[i,j]/ray[1,j] > 0 ){
// 						return(i);
// 					}
// 				}
// 			}
// 			i++;
// 			continue;
// 		}
// 	}
// 	return(0);
// }							/* RETURN: bool (i=yes, ray equals the i-th row of rays, 0=no, ray is not contained in rays) */
// proc trophialsLIB "trophialsmatrix11.lib"; ring r = 0,(x,y,z,v,w),dp;ideal I = x+y+z+w+v,x+z-v; poly f = xy+17xv+7xw-3yz-13yw-5yw+7zv+9zw-21v2-29w2; ideal J = I+f; trophials_tropicalize(J);_inner_cone_point(matrix A){			/* INPUT: cone generators */
// 	int i,j;
// 	matrix R[1][ncols(A)];
// 	for(i = 1; i <= ncols(A); i++){
// 		R[1,i] = A[1,i];
// 		for(j = 2; j <= nrows(A); j++){
// 			R[1,i] = R[1,i] + A[j,i];
// 		}
// 	}
// 	return(R);
// }							/* RETURN: interior point of that cone */
// //////////////////////////////////////////////////////////////////
// // for polymake //
// //////////////////////////////////////////////////////////////////
// proc trophials_list_to_matrix(list L){		/* INPUT: list L containing support */
// 	int m = size(L);
// 	int n = size(L[1]);
// //	matrix A[m][n+1];
// 	matrix A[m][n];
// 	int i,j;
// 	for(i = 1; i <= m; i++){
// // 		A[i,1] = 1;
// 		for(j = 1; j <= size(L[i]); j++){
// // 			A[i,j+1] = L[i][j];
// 			A[i,j] = L[i][j];
// 		}
// 	}
// 	return(A);
// }						/* RETURN: matrix containing affine support */
// proc trophials_shift_matrix(matrix A){		/* INPUT: matrix A */
// 	matrix B[nrows(A)][ncols(A)+1];
// 	B[1..nrows(A),2..ncols(A)+1] = A;
// 	for(int i = 1; i <= nrows(A); i++){
// 		B[i,1] = 1;
// 	}
// 	return(B);
// }						/* RETURN: shifting A to (1,A) */
// //////////////////////////////////////////////////////////////////
// // Fr trophials_cusps //
// //////////////////////////////////////////////////////////////////
// proc trophials_cusps(intmat A){			/* INPUT: support matrix A */
// 	print("-----------------");
// 	print("trophials_cusps computations");
// 	print("-----------------");
// 	LIB "ainvar.lib";
// 	int n = ncols(A);
// 	int i;
// 	if( n != nvars(basering) - 2 ){
// 		ERROR("Size of support and number of variables x(i) do not coincide!");
// 	}
// 
// 	list L = trophials_monomials(n,2);
// 
// 	poly f = 0;
// 
// 	for(i = 1; i <= n; i++){
// 		f = f + x(i)*x^A[1,i]*y^A[2,i];
// 	}
// 	if ( f == 0 ){
// 		ERROR("f is the zero polynomial.");
// 	}
// 	
// // 	print("Polynomial:");
// // 	print(f);
// 	
// 	matrix mx[n+2][1];
// 	matrix my[n+2][1];
// 	
// 	mx[n+1,1]=1;
// 	my[n+2,1]=1;
// 	
// 	poly fx = derivate(mx,f);
// 	poly fxx = derivate(mx,fx);
// 	
// 	poly fy = derivate(my,f);
// 	poly fxy = derivate(mx,fy);
// 	poly fyy = derivate(my,fy);
// 	
// 	matrix H[2][2] = fxx,fxy,fxy,fyy;
// 	poly detH = subst(det(H),x,1,y,1);
// 
// 	print("f ="),f;
// 	print("fx ="),fx;
// 	print("fxx ="),fxx;
// 	print("fy ="),fy;
// 	print("fyy ="),fyy;
// 	print("detH ="),detH;
// //	print(detH);
// 	
// // 	ideal J = subst(f,x,1,y,1),subst(derivate(mx,f),x,1,y,1),subst(derivate(my,f),x,1,y,1),subst(detH,x,1,y,1);
// 
// 	list L1,L2,L3,L;
// 	
// 	for(i = 1; i <= n; i++){
// 		L1[i] = 1;
// 		L2[i] = A[1,i];
// 		L3[i] = A[2,i];
// 	}
// 	list mon = trophials_monomials(n,2);
// 	
// 	for( i = 1; i <= size(mon); i++){
// 		L[i] = 0;
// 	}
// 
// 	intvec e;
// 	intvec zero = 0;
// 	
// // 	trophials_shorten(leadexp(g));
// 	
// 	intvec avoid;
// 	int avoid_counter = 1;
// 
// 	while( detH != 0 ){
// 
// 		e = zero;
// 		e = trophials_shorten(leadexp(detH));
// 		
// 		for( i = 1; i <= size(mon); i++){
// 			if( e == mon[i] ){
// 				L[i] = leadcoef(detH);
// 				avoid[avoid_counter] = i;
// 				avoid_counter++;
// 			}
// 		}
// 		
// 		detH = detH - leadcoef(detH)*leadmonom(detH);
// 	}
// // 	print("avoid ="),avoid;
// 
// 	if( size(avoid) == size(mon) ){
// 		print("det(H) has full support.");
// 	}
// // 	print("size mon = "),size(mon);
// // 	print(L);
// 	
// 
// 	list IL = L1,L2,L3,L;
// 	
// // 	print("Input of trophials_example:");
// // 	print(IL);
// 	
// 	trophials_example(L1,L2,L3,L);
// 	
// 	print("-----------------");
// 	print("Support matrix:");
// 	print("-----------------");
// 	print(A);
// 	
// // 	nameof(basering);
// // 	return(IL);
// }						/* RETURN: generic ideal I */
// proc trophials_shorten(intvec v){			/* INPUT: intvec v */
// 	intvec res;
// 	int i;
// 	for(i = 1; i <= size(v)-2; i++){
// 		res[i] = v[i];
// 	}
// 	return(res);
// }						/* RETURN: intvec v' = v - last two components */
// //////////////////////////////////////////////////////////////////
// // Konvertierungsfunktionen //
// //////////////////////////////////////////////////////////////////
// proc SMatrixToPMatrix(string name,matrix B){	/* INPUT: string for name, matrix B */
// // 	string res;
// // 	int i,j;
// // 	int n = ncols(B);
// // 	int m = nrows(B);
// // 	res = "$"+name+"= new Matrix<Rational>([";
// // 	for(i = 1; i<= m; i++){
// // 		res = res + "[";
// // 		for(j = 1; j <= n; j++){
// // 			res = res + string(B[i,j])+",";
// // 		}
// // 		res = res[1,size(res)-1] + "],";
// // 	}
// // 	res = res[1,size(res)-1]+"]);";
// // 	return(res);
// }						/* RETURN: string for polymake */
// proc SListToPArray(string name, list L){			/* INPUT: list L */
// 	int i,j;
// 	int n = size(L);
// 	string res = "$"+name+" = new Array<Set<Int>>(";
// 	int k = size(L[1]);
// 	res = res+"[";
// 	for(i = 1; i <= n; i++)
// 	{
// 		res = res+"[";
// 		for(j = 1; j <= k; j++)
// 		{
// 			res = res + string(L[i][j]-1)+",";
// 		}
// 		res = res[1,size(res)-1] +"],";
// 	}
// 	res = res[1,size(res)-1]+"]);";
// 	return(res);
// }						/* RETURN: string for polymake */
// proc SFanToPFan(list fan, string name){			/* INPUT: list fan = (1. rays, 2. cones) */
// 	string p_fan = "use application \"fan\"; use vars '$"+name+"','$rays','$cones','$lineality';"+SMatrixToPMatrix("rays",fan[1])+SListToPArray("cones",fan[2])+SMatrixToPMatrix("lineality",fan[3])+"$"+name+" = new PolyhedralFan<Rational>(RAYS=>$rays,MAXIMAL_CONES=>$cones,LINEALITY_SPACE=>$lineality);";
// 	write("polymake_fan",p_fan);
// }						/* RETURN: writes data in file for polymake */